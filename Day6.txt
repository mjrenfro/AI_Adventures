Local Search
-------------

What is a good admissible heuristic?/
  -A heuristic with as small effective branching factor as possible
  -Small effective branching factor means small average number
  of successors to expand

Effective Branching Factor
-------------------------
  The quality of a heuristic is characterized by the effective
  branching factor b* (the # of successors generated by a "typical"
  node for a given search problem )
  --If the total number of nodes processed by
  A* search is N and the solution depth is d, then b* is the branching
  factor that a uniform tree of depth d would have to have
  in order to contain N+1 nodes.
  Thus
    N=(b*)

How to compare two Heuristics?
-------------------------------
-If h1 and h2 are both admissible Heuristics and
h2(n)>=h1(n) for all n then h2 dominates h1

Combining Heuristics
--------------------
Suppose we have a collection of admissible heuristics
h1(n), h2(n), ...hm(n), but none of them dominates of
the others

The heuristics can be combined by the following
  h(n)=max of heuristics in the collection

Maximal admissible heuristic for A* search

A heuristic that is NOT dominated by any other admissible
heuristic that can be defined using the given knowledge

Problems/Restrictions in Classical Searches
--------------------------------------------
The classical search algorithms studied so far explore the
state spaces systematically which means memory inefficient

Also, they only solve certain types of problems:
(Like a Rubik's Cube)
  Observable
  Deterministic
  Known environments

Other types of problems:
(Like a N-Queens)
  Local search
  Search with nondeterministic actions
  Search with partial observations

Local Search Algorithms
  If the path to the goal does not matter we may consider
  local search algorithms

  -Operates using a single current node (rather than multiple parts)
  -And generally move to only neighbors of that node
  -Typically the paths followed by the search are not retained

Advantages of local search
--------------------------
  -Local search uses very little memory usually a constant
  amount of memory
  -They can find reasonable solutions in large or even
  infinite (continuous state spaces) that systematic algorithms
  would not function in

Optimization
------------

Some types of search problems can be formulated in terms of
optimization

  -Have an objective function that states about the quality
  of a state (possible solution), and we want to find a good
  solution by minimizing or maximizing the value of this function


Traveling Salesman Problem

Hill-Climbing (greedy) search
  -Can get stuck in local optima


N-Queens Problem
----------------

Put n queens on an n x n board with no two queens on the same
row, column, or diagonal state space
  Output: All possible n-queen configurations

Objective function: # of pairwise conflicts (want to min)
  Move one queen within its column to reduce conflicts
